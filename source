KYO = {
    Cam = {
        ["Enabled"] = false,
        ["Prediction"] = 0.13,
        ["Part"] = "Head",
        ["Keybind"] = "c",

        ["UseShake"] = false,
        ["ShakeValue"] = 10,

        ["UseSmoothing"] = false,
        ["SmoothingAmount"] = 0.02,
        ["EasingStyle"] = Enum.EasingStyle.Linear,
        ["EasingDirection"] = Enum.EasingDirection.In,

        ["Resolver"] = false,
        ["ResolverTune"] = 0.13,

        ["UnlockOnTargetDeath"] = false,
        ["UnlockOnOwnDeath"] = false,

        FieldOfView = {
            ["Visible"] = false,
            ["Filled"] = false,
            ["Color"] = Color3.fromRGB(255, 255, 144),
            ["Transparency"] = 1,
            ["Radius"] = 30,
            ["Angle"] = 90, -- Field of view angle in degrees
        },
    },
    Both = {
        ["Notifications"] = false,
        ["Duration"] = 3,

        ["VisibleCheck"] = false,
        ["FriendCheck"] = false,
        ["CrewCheck"] = false,
        ["TeamCheck"] = false,
        ["KOCheck"] = false,
    },
    Target = {
        ["Enabled"] = false,
        ["Keybind"] = "c",
        ["Prediction"] = 0.138,
        ["Part"] = "HumanoidRootPart",
        ["UsePrediction"] = false,

        ["Resolver"] = false,
        ["ResolverTune"] = 0.138,

        ["StrafeEnabled"] = false,
        ["StrafeRadius"] = 10,
        ["StrafeSpeed"] = 5,
        ["StrafeHeight"] = 0,

        ["Notify"] = false,

        Drawings = {
            ["Tracer"] = false,
            ["Color"] = Color3.fromRGB(255, 255, 255),
            ["Thickness"] = 1,
            ["Transparency"] = 1,
        },

        FieldOfView = {
            ["Visible"] = false,
            ["Filled"] = false,
            ["Color"] = Color3.fromRGB(255, 0, 0),
            ["Transparency"] = 1,
            ["Radius"] = 30,
        },
    },
    Macro = {
        ["Enabled"] = false,
        ["Keybind"] = "m",
    },
}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera

local Mouse = LocalPlayer:GetMouse()

local CamKeybind = false
local TargetKeybind = false
local MacroKeybind = false
local MrChosenOne
local angle = 0
local previousPrediction = KYO.Target.Prediction

local CamCircleFOV = Drawing.new("Circle")
CamCircleFOV.Color = KYO.Cam.FieldOfView.Color
CamCircleFOV.Thickness = 1
CamCircleFOV.NumSides = 9e9
CamCircleFOV.Radius = KYO.Cam.FieldOfView.Radius * 3
CamCircleFOV.Transparency = KYO.Cam.FieldOfView.Transparency
CamCircleFOV.Visible = KYO.Cam.FieldOfView.Visible
CamCircleFOV.Filled = KYO.Cam.FieldOfView.Filled

local TargetCircleFOV = Drawing.new("Circle")
TargetCircleFOV.Color = KYO.Target.FieldOfView.Color
TargetCircleFOV.Thickness = 1
TargetCircleFOV.NumSides = 9e9
TargetCircleFOV.Radius = KYO.Target.FieldOfView.Radius * 3
TargetCircleFOV.Transparency = KYO.Target.FieldOfView.Transparency
TargetCircleFOV.Visible = KYO.Target.FieldOfView.Visible
TargetCircleFOV.Filled = KYO.Target.FieldOfView.Filled

game:GetService("RunService").Heartbeat:Connect(function()
    CamCircleFOV.Position = Vector2.new(Mouse.X, Mouse.Y + 35)
    TargetCircleFOV.Position = Vector2.new(Mouse.X, Mouse.Y + 35)
    task.wait()
end)

local library = loadstring(game:HttpGet("https://raw.githubusercontent.com/imagoodpersond/puppyware/main/lib"))()
local NotifyLibrary = loadstring(game:HttpGet("https://raw.githubusercontent.com/imagoodpersond/puppyware/main/notify"))()
local Notify = NotifyLibrary.Notify
makefolder("Example")

local Window = library:new({name = "KYO", accent = Color3.fromRGB(175, 252, 149), textsize = 13})
local Legit = Window:page({name = "Legit"})

local Camlock = Legit:section({name = "Aim Assist", side = "left", size = 445})
local Checks = Legit:section({name = "Checks", side = "right", size = 140})  -- Adjusted size to fit KO Check
local Macro = Legit:section({name = "Macro", side = "right", size = 150})  -- Adjusted size to fit content

local Rage = Window:page({name = "Rage"})
local AimbotSection = Rage:section({name = "Aimbot", side = "left", size = 300})
local OrbitSection = Rage:section({name = "Orbit", side = "right", size = 200})
local CFrameSection = Rage:section({name = "CFrame", side = "left", size = 80})
local ESPSection = Rage:section({name = "ESP", side = "right", size = 130})

-- Variables for ESP
local playerHighlights = {}
local playerNametags = {}
local espHighlightEnabled = false
local espNametagEnabled = false

-- Highlight Function
local function applyHighlight(player)
    local function onCharacterAdded(character)
        if character:FindFirstChildOfClass("Highlight") then return end
        
        local highlight = Instance.new("Highlight", character)
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        highlight.FillTransparency = 0.5
        highlight.OutlineTransparency = 0
        highlight.FillColor = Color3.fromRGB(255, 255, 255)
        highlight.OutlineColor = Color3.fromRGB(0, 0, 0)
        playerHighlights[player] = highlight
    end

    if player.Character then
        onCharacterAdded(player.Character)
    end
    player.CharacterAdded:Connect(onCharacterAdded)
end

local function removeHighlights()
    for _, highlight in pairs(playerHighlights) do
        highlight:Destroy()
    end
    playerHighlights = {}
end

-- Nametag Function
local function applyNametag(player)
    local function onCharacterAdded(character)
        if playerNametags[player] then return end
        
        local billboard = Instance.new("BillboardGui", character)
        billboard.Size = UDim2.new(0, 200, 0, 50)
        billboard.StudsOffset = Vector3.new(0, 3, 0)
        billboard.Adornee = character:WaitForChild("Head")
        
        local textLabel = Instance.new("TextLabel", billboard)
        textLabel.Size = UDim2.new(1, 0, 1, 0)
        textLabel.Text = player.Name
        textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        textLabel.BackgroundTransparency = 1
        textLabel.TextSize = 18
        textLabel.TextStrokeTransparency = 0.5
        textLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
        textLabel.Font = Enum.Font.SourceSansBold
        
        playerNametags[player] = billboard
    end

    if player.Character then
        onCharacterAdded(player.Character)
    end
    player.CharacterAdded:Connect(onCharacterAdded)
end

local function removeNametags()
    for _, billboard in pairs(playerNametags) do
        billboard:Destroy()
    end
    playerNametags = {}
end

-- ESP Event Listeners
Players.PlayerAdded:Connect(function(player)
    if espHighlightEnabled then
        applyHighlight(player)
    end
    if espNametagEnabled then
        applyNametag(player)
    end
end)

Players.PlayerRemoving:Connect(function(player)
    if playerHighlights[player] then
        playerHighlights[player]:Destroy()
        playerHighlights[player] = nil
    end
    if playerNametags[player] then
        playerNametags[player]:Destroy()
        playerNametags[player] = nil
    end
end)

RunService.RenderStepped:Connect(function()
    if espHighlightEnabled then
        for player, highlight in pairs(playerHighlights) do
            highlight.FillColor = Color3.fromRGB(255, 255, 255)
            highlight.OutlineColor = Color3.fromRGB(0, 0, 0)
        end
    end
    if espNametagEnabled then
        for player, billboard in pairs(playerNametags) do
            local textLabel = billboard:FindFirstChild("TextLabel")
            if textLabel then
                textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
                textLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
            end
        end
    end
end)

ESPSection:toggle({name = "Highlight", def = false, callback = function(state)
    espHighlightEnabled = state
    if state then
        Notify("Highlight ESP Activated")
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer then
                applyHighlight(player)
            end
        end
    else
        Notify("Highlight ESP Deactivated")
        removeHighlights()
    end
end})

ESPSection:toggle({name = "Nametag", def = false, callback = function(state)
    espNametagEnabled = state
    if state then
        Notify("Nametag ESP Activated")
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer then
                applyNametag(player)
            end
        end
    else
        Notify("Nametag ESP Deactivated")
        removeNametags()
    end
end})

CFrameSection:toggle({name = "Enabled", def = false, callback = function(Boolean)
    cframespeedtoggle = Boolean
end})

CFrameSection:slider({name = "Speed", def = 2, max = 10, min = 1, rounding = false, callback = function(Value)
    speedvalue = Value
end})

AimbotSection:toggle({name = "Enabled", def = false, callback = function(Boolean)
    KYO.Target.Enabled = Boolean
    if not Boolean then
        stopAimbot()
    end
end})

AimbotSection:dropdown({name = "Key", def = "c", max = 7, options = {"c", "q", "x", "z","t", "v", "g", "y"}, callback = function(part)
    KYO.Target.Keybind = part
end})

AimbotSection:dropdown({name = "Part", def = "HumanoidRootPart", max = 7, options = {"Head", "HumanoidRootPart", "UpperTorso", "LowerTorso","LeftHand", "RightHand", "LeftFoot", "RightFoot"}, callback = function(part)
    KYO.Target.Part = part
end})

AimbotSection:toggle({name = "Resolver", def = false, callback = function(Boolean)
    KYO.Target.Resolver = Boolean
end})

AimbotSection:toggle({name = "Notifications", def = false, callback = function(Boolean)
    KYO.Target.Notify = Boolean
end})

AimbotSection:toggle({name = "Show FOV", def = false, callback = function(Boolean)
    TargetCircleFOV.Visible = Boolean
end})

AimbotSection:toggle({name = "Prediction", def = false, callback = function(Boolean)
    KYO.Target.UsePrediction = Boolean
    if not Boolean then
        previousPrediction = KYO.Target.Prediction
        KYO.Target.Prediction = 0
    else
        KYO.Target.Prediction = previousPrediction
    end
end})

AimbotSection:slider({name = "Prediction", def = 0.3, max = 0.4, min = 0.01, rounding = false, callback = function(Value)
    if KYO.Target.UsePrediction then
        KYO.Target.Prediction = Value
        previousPrediction = Value
    end
end})

AimbotSection:slider({name = "Resolver Tune", def = 0.3, max = 0.4, min = 0.01, rounding = false, callback = function(Value)
    KYO.Target.ResolverTune = Value
end})

AimbotSection:slider({name = "FOV Radius", def = 30, max = 250, min = 1, rounding = false, callback = function(Value)
    KYO.Target.FieldOfView.Radius = Value
    TargetCircleFOV.Radius = Value * 3
end})

OrbitSection:toggle({name = "Toggle Orbit", def = false, callback = function(Boolean)
    KYO.Target.StrafeEnabled = Boolean
    if KYO.Target.Enabled and Boolean then
        startStrafing()
    else
        stopStrafing()
    end
end})

OrbitSection:toggle({name = "Look At", def = false, callback = function(Boolean)
    KYO.Target.LookAt = Boolean
end})

OrbitSection:toggle({name = "Spectate", def = false, callback = function(Boolean)
    KYO.Target.Spectate = Boolean
end})

OrbitSection:slider({name = "Radius", def = 5, max = 20, min = 1, rounding = false, callback = function(Value)
    KYO.Target.StrafeRadius = Value
end})

OrbitSection:slider({name = "Speed", def = 5, max = 5, min = 0.1, rounding = false, callback = function(Value)
    KYO.Target.StrafeSpeed = Value
end})

Camlock:toggle({name = "Enabled", def = false, callback = function(Boolean)
    KYO.Cam.Enabled = Boolean
end})

Camlock:toggle({name = "Smoothing", def = false, callback = function(Boolean)
    KYO.Cam.UseSmoothing = Boolean
end})

Camlock:toggle({name = "Add Shake", def = false, callback = function(Boolean)
    KYO.Cam.UseShake = Boolean
end})

Camlock:toggle({name = "Show FOV", def = false, callback = function(Boolean)
    CamCircleFOV.Visible = Boolean
end})

Camlock:slider({name = "Prediction", def = 0.3, max = 0.4, min = 0.01, rounding = false, callback = function(Value)
    KYO.Cam.Prediction = Value
end})

Camlock:slider({name = "Smoothing Amount", def = 0.02, max = 1, min = 0.001, rounding = false, callback = function(Value)
    KYO.Cam.SmoothingAmount = Value
end})

Camlock:slider({name = "Shake Value", def = 10, max = 10, min = 1, rounding = false, callback = function(Value)
    KYO.Cam.ShakeValue = Value
end})

Camlock:slider({name = "Resolver Tune", def = 0.13, max = 0.2, min = 0.1, rounding = false, callback = function(Value)
    KYO.Cam.ResolverTune = Value
end})

Camlock:slider({name = "FOV Radius", def = 20, max = 250, min = 1, rounding = false, callback = function(Value)
    KYO.Cam.FieldOfView.Radius = Value
    CamCircleFOV.Radius = Value * 3
end})

Camlock:toggle({name = "Resolver", def = false, callback = function(Boolean)
    KYO.Cam.Resolver = Boolean
end})

Camlock:toggle({name = "Unlock On Target Death", def = false, callback = function(Boolean)
    KYO.Cam.UnlockOnTargetDeath = Boolean
end})

Camlock:toggle({name = "Unlock On My Death", def = false, callback = function(Boolean)
    KYO.Cam.UnlockOnOwnDeath = Boolean
end})

Camlock:dropdown({name = "Part", def = "Head", max = 7, options = {"Head", "HumanoidRootPart", "UpperTorso", "LowerTorso","LeftHand", "RightHand", "LeftFoot", "RightFoot"}, callback = function(part)
    KYO.Cam.Part = part
end})

Camlock:dropdown({name = "Key", def = "c", max = 7, options = {"c", "q", "x", "z","t", "v", "g", "y"}, callback = function(part)
    KYO.Cam.Keybind = part
end})

Checks:toggle({name = "Visible Check", def = false, callback = function(Boolean)
    KYO.Both.VisibleCheck = Boolean
end})

Checks:toggle({name = "Friend Check", def = false, callback = function(Boolean)
    KYO.Both.FriendCheck = Boolean
end})

Checks:toggle({name = "Crew Check", def = false, callback = function(Boolean)
    KYO.Both.CrewCheck = Boolean
end})

Checks:toggle({name = "Team Check", def = false, callback = function(Boolean)
    KYO.Both.TeamCheck = Boolean
end})

Checks:toggle({name = "KO Check", def = false, callback = function(Boolean)
    KYO.Both.KOCheck = Boolean
end})

local Settings = Window:page({name = "Settings"})
local ConfigSection = Settings:section({name = "Config", side = "left", size = 250})
local UIKeybindSection = Settings:section({name = "UI Keybind", side = "right", size = 100})  -- Added UI Keybind section
local ConfigLoader = ConfigSection:configloader({folder = "Example"})

-- Toggle UI Key
local toggleUIKey = Enum.KeyCode.RightControl
local uiVisible = true

UserInputService.InputBegan:Connect(function(input)
    if input.KeyCode == toggleUIKey then
        uiVisible = not uiVisible
        Window:set_visible(uiVisible)
    end
end)

function Notify(Text)
    game.StarterGui:SetCore("SendNotification", {
        Title = "KYO",
        Text = Text,
        Duration = KYO.Both.Duration,
    })
end

Mouse.KeyDown:Connect(function(ChosenKey)
    if ChosenKey == KYO.Cam.Keybind and KYO.Cam.Enabled then
        if CamKeybind == false then
            CamKeybind = true
            MrChosenOne = FindClosestPlayer()
            if KYO.Both.Notifications then
                Notify("Locked Onto " .. MrChosenOne.DisplayName)
            end
        elseif CamKeybind == true then
            CamKeybind = false
            if KYO.Both.Notifications then
                Notify("No Longer Locked On")
            end
        end
    end
end)

task.spawn(function()
    while true do
        task.wait()
        if CamKeybind then
            if MrChosenOne and MrChosenOne.Parent then
                local Opp = MrChosenOne.Character[KYO.Cam.Part].Position + MrChosenOne.Character[KYO.Cam.Part].Velocity * KYO.Cam.Prediction
                
                if KYO.Cam.UseSmoothing then
                    local TweenService = game:GetService("TweenService")
                    local tweenInfo = TweenInfo.new(
                        KYO.Cam.SmoothingAmount,
                        KYO.Cam.EasingStyle,
                        KYO.Cam.EasingDirection
                    )
                    local tween = TweenService:Create(Camera, tweenInfo, {CFrame = CFrame.new(Camera.CFrame.p, Opp)})
                    tween:Play()
                else
                    Camera.CFrame = CFrame.new(Camera.CFrame.p, Opp)
                end
                
                if KYO.Cam.UseShake then
                    local shakeX = math.random(-KYO.Cam.ShakeValue, KYO.Cam.ShakeValue)
                    local shakeY = math.random(-KYO.Cam.ShakeValue, KYO.Cam.ShakeValue)
                    local shakeZ = math.random(-KYO.Cam.ShakeValue, KYO.Cam.ShakeValue)
                    Camera.CFrame = Camera.CFrame * CFrame.Angles(math.rad(shakeX), math.rad(shakeY), math.rad(shakeZ))
                end
            end
        end
    end
end)

Mouse.KeyDown:Connect(function(ChosenKey)
    if ChosenKey == KYO.Target.Keybind and KYO.Target.Enabled then
        if TargetKeybind == false then
            TargetKeybind = true
            hojixvChosenPlayer = FindClosestPlayer()
            if KYO.Target.Notify then
                Notify("Locked Onto " .. hojixvChosenPlayer.DisplayName)
            end
            startAimbot()
            if KYO.Target.StrafeEnabled then
                startStrafing()
            end
        elseif TargetKeybind == true then
            TargetKeybind = false
            if KYO.Target.Notify then
                Notify("No Longer Locked On")
            end
            stopAimbot()
            stopStrafing()
        end
    end
end)

Mouse.KeyDown:Connect(function(ChosenKey)
    if ChosenKey == KYO.Macro.Keybind and KYO.Macro.Enabled then
        if MacroKeybind == false then
            MacroKeybind = true
            startMacro()
        elseif MacroKeybind == true then
            MacroKeybind = false
            stopMacro()
        end
    end
end)

function startMacro()
    if game.PlaceId == 2788229376 then
        if getgenv().L_15 == true then
            game.StarterGui:SetCore("SendNotification", {
                Title = "Speed Glitch",
                Text = "Already Executed",
            })
            return
        end
        getgenv().L_15 = true -- don't change me
        
        getgenv().Notification = true
        getgenv().AutoMacro = true
        getgenv().Macro = true
        getgenv().AutoMacroKey = KYO.Macro.Keybind
        getgenv().MacroKey = KYO.Macro.Keybind
        getgenv().MacroMode = "Keyboard" -- Keyboard, Mouse
        getgenv().GodMacro = true
        getgenv().GodMacroKey = KYO.Macro.Keybind
        getgenv().GodMacroAuto = true

        game:GetService("UserInputService").InputBegan:Connect(function(input, chatting)
            if input.UserInputType == Enum.UserInputType.Keyboard then
                if chatting then
                    IsChatting = true
                else
                    IsChatting = false
                end
                if input.KeyCode == KYO.Macro.Keybind then
                    if IsChatting ~= false then
                        return
                    end
                    if not AutoMacroToggle then
                        if Notification == true then
                            game.StarterGui:SetCore("SendNotification", {
                                Title = "AutoMacro",
                                Text = "Activated",
                            })
                        end
                        AutoMacroToggle = true
                        Instance.new("Animation", game:GetService("ReplicatedStorage"):findFirstChild("ClientAnimations")).Name = 'Greet'
                        game:GetService("ReplicatedStorage"):findFirstChild("ClientAnimations"):findFirstChild("Greet").AnimationId = 'rbxassetid://3189777795'
                        local Greet = game.ReplicatedStorage.ClientAnimations.Greet
                        local Humanoid = game.Players.LocalPlayer.Character.Humanoid
                        local Animation = Humanoid:LoadAnimation(Greet)
                        Animation:Play()
                        wait(1.6)
                        for i, v in next, game:GetService("Players").LocalPlayer.Backpack:GetChildren() do
                            if v:IsA("Tool") and v.Name ~= "Combat" or v.Name ~= "[Boombox]" then
                                game:GetService("Players").LocalPlayer.Character:findFirstChildOfClass'Humanoid':EquipTool(v)
                            end
                        end
                        wait()
                        game:GetService("VirtualInputManager"):SendKeyEvent(true, "S", false, game)
                        spawn(function()
                            if MacroMode == "Keyboard" then
                                while AutoMacroToggle == true do
                                    wait()
                                    game:GetService("VirtualInputManager"):SendKeyEvent(true, "I", false, game)
                                    wait()
                                    game:GetService("VirtualInputManager"):SendKeyEvent(true, "O", false, game)
                                    wait()
                                    game:GetService("VirtualInputManager"):SendKeyEvent(true, "I", false, game)
                                    wait()
                                    game:GetService("VirtualInputManager"):SendKeyEvent(true, "O", false, game)
                                    wait()
                                    game:GetService("VirtualInputManager"):SendKeyEvent(true, "I", false, game)
                                    wait()
                                    game:GetService("VirtualInputManager"):SendKeyEvent(true, "O", false, game)
                                    wait()
                                    game:GetService("VirtualInputManager"):SendKeyEvent(true, "I", false, game)
                                    wait()
                                    game:GetService("VirtualInputManager"):SendKeyEvent(true, "O", false, game)
                                    wait()
                                end
                            elseif MacroMode == "Mouse" then
                                while AutoMacroToggle == true do
                                    wait()
                                    game:GetService("VirtualInputManager"):SendMouseWheelEvent("0", "0", true, game)
                                    wait()
                                    game:GetService("VirtualInputManager"):SendMouseWheelEvent("0", "0", false, game)
                                    wait()
                                    game:GetService("VirtualInputManager"):SendMouseWheelEvent("0", "0", true, game)
                                    wait()
                                    game:GetService("VirtualInputManager"):SendMouseWheelEvent("0", "0", false, game)
                                    wait()
                                    game:GetService("VirtualInputManager"):SendMouseWheelEvent("0", "0", true, game)
                                    wait()
                                    game:GetService("VirtualInputManager"):SendMouseWheelEvent("0", "0", false, game)
                                    wait()
                                    game:GetService("VirtualInputManager"):SendMouseWheelEvent("0", "0", true, game)
                                    wait()
                                    game:GetService("VirtualInputManager"):SendMouseWheelEvent("0", "0", false, game)
                                    wait()
                                end
                            end
                        end)
                        Animation:Stop()
                        Macro =
                            game:service'Players'.LocalPlayer.Character:findFirstChildOfClass'Humanoid'.Running:Connect(function()
                                Animation:Stop()
                            end)
                    else
                        if Notification == true then
                            game.StarterGui:SetCore("SendNotification", {
                                Title = "AutoMacro",
                                Text = "Deactivated",
                            })
                        end
                        AutoMacroToggle = false
                        local Greet = game.ReplicatedStorage.ClientAnimations.Greet
                        local Humanoid = game.Players.LocalPlayer.Character.Humanoid
                        local Animation = Humanoid:LoadAnimation(Greet)
                        Animation:Stop()
                        game:GetService("ReplicatedStorage"):findFirstChild("ClientAnimations"):findFirstChild("Greet"):Remove()
                        Macro:Disconnect()
                    end
                end
            end
        end)
    end
end

function stopMacro()
    MacroKeybind = false
    if Notification == true then
        game.StarterGui:SetCore("SendNotification", {
            Title = "Macro",
            Text = "Deactivated",
        })
    end
end

Macro:toggle({name = "Enabled", def = false, callback = function(Boolean)
    KYO.Macro.Enabled = Boolean
    if not Boolean then
        stopMacro()
    end
end})

Macro:dropdown({name = "Key", def = "m", max = 7, options = {"c", "q", "x", "z", "t", "v", "g", "y", "m"}, callback = function(part)
    KYO.Macro.Keybind = part
end})

local function pointOnCircle(angle)
    local x = KYO.Target.StrafeRadius * math.cos(angle)
    local z = KYO.Target.StrafeRadius * math.sin(angle)
    return Vector3.new(x, 0, z)
end

function FindClosestPlayer()
    local localPlayer = game.Players.LocalPlayer
    local shortestDistance = math.huge
    local nearestPlayer = nil
    local localMouse = Vector2.new(localPlayer:GetMouse().X, localPlayer:GetMouse().Y)
    
    for _, otherPlayer in pairs(game.Players:GetPlayers()) do
        if otherPlayer ~= localPlayer and otherPlayer.Character and otherPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local otherPlayerPosition = otherPlayer.Character.HumanoidRootPart.Position
            local pos = game:GetService("Workspace").CurrentCamera:WorldToViewportPoint(otherPlayerPosition)
            local distance = (Vector2.new(pos.X, pos.Y) - localMouse).Magnitude
            if distance < shortestDistance and distance <= TargetCircleFOV.Radius then
                -- Calculate the angle between the camera's forward direction and the direction to the target
                local cameraLookVector = game:GetService("Workspace").CurrentCamera.CFrame.LookVector
                local directionToTarget = (otherPlayerPosition - game:GetService("Workspace").CurrentCamera.CFrame.p).unit
                local angleToTarget = math.deg(math.acos(cameraLookVector:Dot(directionToTarget)))

                -- Only consider players within the specified FOV angle
                if angleToTarget <= KYO.Cam.FieldOfView.Angle then
                    shortestDistance = distance
                    nearestPlayer = otherPlayer
                end
            end
        end
    end
    return nearestPlayer
end

function startAimbot()
    aimbotConnection = RunService.RenderStepped:Connect(function()
        if hojixvChosenPlayer and hojixvChosenPlayer.Character and hojixvChosenPlayer.Character:FindFirstChild(KYO.Target.Part) then
            local targetPart = hojixvChosenPlayer.Character[KYO.Target.Part]
            local aimPosition = targetPart.Position + (targetPart.Velocity * KYO.Target.Prediction)
            Camera.CFrame = CFrame.new(Camera.CFrame.Position, aimPosition)
        end
    end)
end

function stopAimbot()
    if aimbotConnection then
        aimbotConnection:Disconnect()
        aimbotConnection = nil
    end
end

function startStrafing()
    if strafeConnection then return end -- Prevent multiple connections

    strafeConnection = RunService.RenderStepped:Connect(function()
        if hojixvChosenPlayer and hojixvChosenPlayer.Character and hojixvChosenPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local targetRootPart = hojixvChosenPlayer.Character.HumanoidRootPart
            angle = angle + math.rad(KYO.Target.StrafeSpeed)

            local circlePosition = targetRootPart.Position + pointOnCircle(angle) + Vector3.new(0, KYO.Target.StrafeHeight, 0)

            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(circlePosition)
            end

            if KYO.Target.LookAt then
                game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(
                    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame.Position, 
                    targetRootPart.Position
                )
            end
        end
    end)
end

function stopStrafing()
    if strafeConnection then
        strafeConnection:Disconnect()
        strafeConnection = nil
    end
end

game:GetService("RunService").Heartbeat:Connect(function()
    if cframespeedtoggle == true then
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame =
            game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame +
            game.Players.LocalPlayer.Character.Humanoid.MoveDirection * speedvalue / 2.5
    end
end)

game:GetService("RunService").Heartbeat:Connect(function()
    if TargetKeybind and KYO.Target.Spectate and hojixvChosenPlayer then
        game:GetService("Workspace").CurrentCamera.CameraSubject = hojixvChosenPlayer.Character.Humanoid
    else
        game:GetService("Workspace").CurrentCamera.CameraSubject = game.Players.LocalPlayer.Character.Humanoid
    end
end)

local hojixz = getrawmetamethod(game)
local char = hojixz.__namecall
setreadonly(hojixz, false)
hojixz.__namecall = newcclosure(function(...)
    local args = {...}
    if TargetKeybind and getnamecallmethod() == "FireServer" and args[2] == "UpdateMousePos" then
        if KYO.Target.Resolver then
            args[3] = hojixvChosenPlayer.Character[KYO.Target.Part].Position + (hojixvChosenPlayer.Character.Humanoid.MoveDirection * KYO.Target.ResolverTune)
        else
            args[3] = hojixvChosenPlayer.Character[KYO.Target.Part].Position +
            (hojixvChosenPlayer.Character[KYO.Target.Part].Velocity * KYO.Target.Prediction)
        end
        return char(unpack(args))
    end
    return char(...)
end)

local OldIndex = nil
OldIndex = hookmetamethod(game, "__index", function(self, Index)
    if not checkcaller() and Mouse and self == Mouse and Index == "Hit" and KYO.Target.Enabled then
        local hojixvz = FindClosestPlayer()
        if hojixvz and hojixvz[KYO.Target.Part] then
            local Formula = nil
            local Position = nil
            local Velocity = hojixvz.HumanoidRootPart.AssemblyLinearVelocity
            local Mov = hojixvz.Humanoid.MoveDirection
            Position = hojixvz[KYO.Target.Part].CFrame

            local DETECTED = false
            if KYO.Target.Resolver then
                local Magnitude = Velocity.magnitude
                local Magnitude2 = Mov.magnitude
                if Magnitude > 84 then
                    DETECTED = true
                elseif Magnitude < 1 and Magnitude2 > 0.01 then
                    DETECTED = true
                elseif Magnitude > 5 and Magnitude2 < 0.01 then
                    DETECTED = true
                end
            end

            if Position then
                if DETECTED then
                    local MoveDirection = Mov * 16
                    Formula = Position + (MoveDirection * KYO.Target.ResolverTune)
                else
                    Formula = Position + (Vector3.new(Velocity.X, (Velocity.Y * 0.5), Velocity.Z) * KYO.Target.Prediction)
                end
            end

            if Formula then
                return Index == "Hit" and Formula or OldIndex(self, Index)
            end
        end
    end
    return OldIndex(self, Index)
end)
